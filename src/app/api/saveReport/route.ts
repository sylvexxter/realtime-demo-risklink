import { NextResponse } from 'next/server';
import fs from 'fs'; // Node.js file system module
import path from 'path'; // Node.js path module

// Define the expected structure of the request body
interface SaveReportRequestBody {
  filePath: string; // e.g., "training_awareness_report.json" or "asset_management/summary.json"
  content: string;  // The JSON string generated by the LLM
}

// Define the allowed base directory for reports relative to the project root, *inside* src
const BASE_REPORTS_DIR = path.join(process.cwd(), 'src', 'json_reports');

export async function POST(req: Request) {
  try {
    // 1. Parse Request Body
    // Ensure the request has a body and parse it as JSON
    let body: SaveReportRequestBody;
    try {
      body = await req.json();
    } catch (parseError) {
      console.error("Failed to parse request body:", parseError);
      return NextResponse.json({ message: 'Bad Request: Invalid JSON in request body.' }, { status: 400 });
    }

    const { filePath, content } = body;

    // 2. Validate Input Presence and Type
    if (!filePath || typeof filePath !== 'string' || !content || typeof content !== 'string') {
      return NextResponse.json(
        { message: 'Bad Request: Both filePath (string) and content (string) are required.' },
        { status: 400 }
      );
    }

    // 3. --- Security Check: Prevent Directory Traversal ---
    // Construct the intended absolute path based on the base directory and the user-provided relative path
    const intendedPath = path.join(BASE_REPORTS_DIR, filePath);

    // Normalize the path (resolves '..', '.', double slashes, etc.)
    const normalizedPath = path.normalize(intendedPath);

    // **Crucial Security Check**: Ensure the final normalized path still starts with the intended base directory.
    // This prevents users from specifying paths like '../../../../etc/passwd'.
    if (!normalizedPath.startsWith(BASE_REPORTS_DIR)) {
      console.warn(`Security Alert: Attempted directory traversal blocked for path: ${filePath}`);
      return NextResponse.json(
        { message: 'Forbidden: Invalid file path specified.' },
        { status: 403 } // 403 Forbidden indicates a permissions/security issue
      );
    }

    // 4. Ensure Target Directory Exists
    // Get the directory name from the final normalized path
    const reportDir = path.dirname(normalizedPath);

    // Use fs.promises.mkdir for asynchronous directory creation.
    // The { recursive: true } option means it won't throw an error if the directory already exists
    // and it will create parent directories as needed.
    await fs.promises.mkdir(reportDir, { recursive: true });
    console.log(`Ensured directory exists: ${reportDir}`);


    // 5. Write File Asynchronously
    // Use fs.promises.writeFile for asynchronous writing.
    // This is generally preferred over sync methods in server environments.
    await fs.promises.writeFile(normalizedPath, content, 'utf8');
    console.log(`Report saved successfully to: ${normalizedPath}`);

    // 6. Send Success Response
    return NextResponse.json(
      { message: `Report saved successfully to src/json_reports/${filePath}` }, // Update message to reflect src path
      { status: 200 } // 200 OK indicates success
    );

  } catch (error: any) {
     // Catch potential file system errors (permissions, disk full, etc.)
    console.error('Error occurred in /api/saveReport:', error);
    return NextResponse.json(
      // Provide a generic error message to the client, log the specific error server-side
      { message: `Internal Server Error: ${error.message || 'Failed to save report.'}` },
      { status: 500 } // 500 Internal Server Error for unexpected issues
    );
  }
}

// You can add handlers for other HTTP methods (GET, PUT, DELETE) if needed,
// otherwise Next.js will automatically return a 405 Method Not Allowed for them.
